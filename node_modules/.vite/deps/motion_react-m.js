"use client";
import {
  require_jsx_runtime
} from "./chunk-XREXF2BJ.js";
import {
  __commonJS,
  __toESM,
  require_react
} from "./chunk-QH6HOCAD.js";

// optional-peer-dep:__vite-optional-peer-dep:@emotion/is-prop-valid:motion:true
var require_is_prop_valid_motion_true = __commonJS({
  "optional-peer-dep:__vite-optional-peer-dep:@emotion/is-prop-valid:motion:true"(exports, module) {
    module.exports = {};
    throw new Error(`Could not resolve "@emotion/is-prop-valid" imported by "motion". Is it installed?`);
  }
});

// ../../node_modules/motion/dist/es/framer-motion/dist/es/motion/index.mjs
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);

// ../../node_modules/motion/dist/es/motion-utils/dist/es/noop.mjs
var noop = (any) => any;

// ../../node_modules/motion/dist/es/motion-utils/dist/es/errors.mjs
var warning = noop;
var invariant = noop;
if (true) {
  warning = (check, message) => {
    if (!check && typeof console !== "undefined") {
      console.warn(message);
    }
  };
  invariant = (check, message) => {
    if (!check) {
      throw new Error(message);
    }
  };
}

// ../../node_modules/motion/dist/es/framer-motion/dist/es/motion/index.mjs
var import_react11 = __toESM(require_react(), 1);

// ../../node_modules/motion/dist/es/framer-motion/dist/es/context/LayoutGroupContext.mjs
var import_react = __toESM(require_react(), 1);
var LayoutGroupContext = (0, import_react.createContext)({});

// ../../node_modules/motion/dist/es/framer-motion/dist/es/context/LazyContext.mjs
var import_react2 = __toESM(require_react(), 1);
var LazyContext = (0, import_react2.createContext)({ strict: false });

// ../../node_modules/motion/dist/es/framer-motion/dist/es/context/MotionConfigContext.mjs
var import_react3 = __toESM(require_react(), 1);
var MotionConfigContext = (0, import_react3.createContext)({
  transformPagePoint: (p) => p,
  isStatic: false,
  reducedMotion: "never"
});

// ../../node_modules/motion/dist/es/framer-motion/dist/es/context/MotionContext/index.mjs
var import_react4 = __toESM(require_react(), 1);
var MotionContext = (0, import_react4.createContext)({});

// ../../node_modules/motion/dist/es/framer-motion/dist/es/context/MotionContext/create.mjs
var import_react5 = __toESM(require_react(), 1);

// ../../node_modules/motion/dist/es/framer-motion/dist/es/render/utils/is-variant-label.mjs
function isVariantLabel(v) {
  return typeof v === "string" || Array.isArray(v);
}

// ../../node_modules/motion/dist/es/framer-motion/dist/es/animation/utils/is-animation-controls.mjs
function isAnimationControls(v) {
  return v !== null && typeof v === "object" && typeof v.start === "function";
}

// ../../node_modules/motion/dist/es/framer-motion/dist/es/render/utils/variant-props.mjs
var variantPriorityOrder = [
  "animate",
  "whileInView",
  "whileFocus",
  "whileHover",
  "whileTap",
  "whileDrag",
  "exit"
];
var variantProps = ["initial", ...variantPriorityOrder];

// ../../node_modules/motion/dist/es/framer-motion/dist/es/render/utils/is-controlling-variants.mjs
function isControllingVariants(props) {
  return isAnimationControls(props.animate) || variantProps.some((name) => isVariantLabel(props[name]));
}
function isVariantNode(props) {
  return Boolean(isControllingVariants(props) || props.variants);
}

// ../../node_modules/motion/dist/es/framer-motion/dist/es/context/MotionContext/utils.mjs
function getCurrentTreeVariants(props, context) {
  if (isControllingVariants(props)) {
    const { initial, animate } = props;
    return {
      initial: initial === false || isVariantLabel(initial) ? initial : void 0,
      animate: isVariantLabel(animate) ? animate : void 0
    };
  }
  return props.inherit !== false ? context : {};
}

// ../../node_modules/motion/dist/es/framer-motion/dist/es/context/MotionContext/create.mjs
function useCreateMotionContext(props) {
  const { initial, animate } = getCurrentTreeVariants(props, (0, import_react5.useContext)(MotionContext));
  return (0, import_react5.useMemo)(() => ({ initial, animate }), [variantLabelsAsDependency(initial), variantLabelsAsDependency(animate)]);
}
function variantLabelsAsDependency(prop) {
  return Array.isArray(prop) ? prop.join(" ") : prop;
}

// ../../node_modules/motion/dist/es/framer-motion/dist/es/utils/is-browser.mjs
var isBrowser = typeof window !== "undefined";

// ../../node_modules/motion/dist/es/framer-motion/dist/es/motion/features/definitions.mjs
var featureProps = {
  animation: [
    "animate",
    "variants",
    "whileHover",
    "whileTap",
    "exit",
    "whileInView",
    "whileFocus",
    "whileDrag"
  ],
  exit: ["exit"],
  drag: ["drag", "dragControls"],
  focus: ["whileFocus"],
  hover: ["whileHover", "onHoverStart", "onHoverEnd"],
  tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
  pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
  inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
  layout: ["layout", "layoutId"]
};
var featureDefinitions = {};
for (const key in featureProps) {
  featureDefinitions[key] = {
    isEnabled: (props) => featureProps[key].some((name) => !!props[name])
  };
}

// ../../node_modules/motion/dist/es/framer-motion/dist/es/motion/features/load-features.mjs
function loadFeatures(features) {
  for (const key in features) {
    featureDefinitions[key] = {
      ...featureDefinitions[key],
      ...features[key]
    };
  }
}

// ../../node_modules/motion/dist/es/framer-motion/dist/es/motion/utils/symbol.mjs
var motionComponentSymbol = Symbol.for("motionComponentSymbol");

// ../../node_modules/motion/dist/es/framer-motion/dist/es/motion/utils/use-motion-ref.mjs
var import_react6 = __toESM(require_react(), 1);

// ../../node_modules/motion/dist/es/framer-motion/dist/es/utils/is-ref-object.mjs
function isRefObject(ref) {
  return ref && typeof ref === "object" && Object.prototype.hasOwnProperty.call(ref, "current");
}

// ../../node_modules/motion/dist/es/framer-motion/dist/es/motion/utils/use-motion-ref.mjs
function useMotionRef(visualState, visualElement, externalRef) {
  return (0, import_react6.useCallback)(
    (instance) => {
      instance && visualState.mount && visualState.mount(instance);
      if (visualElement) {
        if (instance) {
          visualElement.mount(instance);
        } else {
          visualElement.unmount();
        }
      }
      if (externalRef) {
        if (typeof externalRef === "function") {
          externalRef(instance);
        } else if (isRefObject(externalRef)) {
          externalRef.current = instance;
        }
      }
    },
    /**
     * Only pass a new ref callback to React if we've received a visual element
     * factory. Otherwise we'll be mounting/remounting every time externalRef
     * or other dependencies change.
     */
    [visualElement]
  );
}

// ../../node_modules/motion/dist/es/framer-motion/dist/es/motion/utils/use-visual-element.mjs
var import_react10 = __toESM(require_react(), 1);

// ../../node_modules/motion/dist/es/framer-motion/dist/es/context/PresenceContext.mjs
var import_react7 = __toESM(require_react(), 1);
var PresenceContext = (0, import_react7.createContext)(null);

// ../../node_modules/motion/dist/es/framer-motion/dist/es/utils/use-isomorphic-effect.mjs
var import_react8 = __toESM(require_react(), 1);
var useIsomorphicLayoutEffect = isBrowser ? import_react8.useLayoutEffect : import_react8.useEffect;

// ../../node_modules/motion/dist/es/framer-motion/dist/es/render/dom/utils/camel-to-dash.mjs
var camelToDash = (str) => str.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase();

// ../../node_modules/motion/dist/es/framer-motion/dist/es/animation/optimized-appear/data-id.mjs
var optimizedAppearDataId = "framerAppearId";
var optimizedAppearDataAttribute = "data-" + camelToDash(optimizedAppearDataId);

// ../../node_modules/motion/dist/es/framer-motion/dist/es/utils/GlobalConfig.mjs
var MotionGlobalConfig = {
  skipAnimations: false,
  useManualTiming: false
};

// ../../node_modules/motion/dist/es/framer-motion/dist/es/frameloop/render-step.mjs
function createRenderStep(runNextFrame) {
  let thisFrame = /* @__PURE__ */ new Set();
  let nextFrame = /* @__PURE__ */ new Set();
  let isProcessing = false;
  let flushNextFrame = false;
  const toKeepAlive = /* @__PURE__ */ new WeakSet();
  let latestFrameData = {
    delta: 0,
    timestamp: 0,
    isProcessing: false
  };
  function triggerCallback(callback) {
    if (toKeepAlive.has(callback)) {
      step.schedule(callback);
      runNextFrame();
    }
    callback(latestFrameData);
  }
  const step = {
    /**
     * Schedule a process to run on the next frame.
     */
    schedule: (callback, keepAlive = false, immediate = false) => {
      const addToCurrentFrame = immediate && isProcessing;
      const queue = addToCurrentFrame ? thisFrame : nextFrame;
      if (keepAlive)
        toKeepAlive.add(callback);
      if (!queue.has(callback))
        queue.add(callback);
      return callback;
    },
    /**
     * Cancel the provided callback from running on the next frame.
     */
    cancel: (callback) => {
      nextFrame.delete(callback);
      toKeepAlive.delete(callback);
    },
    /**
     * Execute all schedule callbacks.
     */
    process: (frameData2) => {
      latestFrameData = frameData2;
      if (isProcessing) {
        flushNextFrame = true;
        return;
      }
      isProcessing = true;
      [thisFrame, nextFrame] = [nextFrame, thisFrame];
      thisFrame.forEach(triggerCallback);
      thisFrame.clear();
      isProcessing = false;
      if (flushNextFrame) {
        flushNextFrame = false;
        step.process(frameData2);
      }
    }
  };
  return step;
}

// ../../node_modules/motion/dist/es/framer-motion/dist/es/frameloop/batcher.mjs
var stepsOrder = [
  "read",
  // Read
  "resolveKeyframes",
  // Write/Read/Write/Read
  "update",
  // Compute
  "preRender",
  // Compute
  "render",
  // Write
  "postRender"
  // Compute
];
var maxElapsed = 40;
function createRenderBatcher(scheduleNextBatch, allowKeepAlive) {
  let runNextFrame = false;
  let useDefaultElapsed = true;
  const state = {
    delta: 0,
    timestamp: 0,
    isProcessing: false
  };
  const flagRunNextFrame = () => runNextFrame = true;
  const steps = stepsOrder.reduce((acc, key) => {
    acc[key] = createRenderStep(flagRunNextFrame);
    return acc;
  }, {});
  const { read, resolveKeyframes, update, preRender, render, postRender } = steps;
  const processBatch = () => {
    const timestamp = MotionGlobalConfig.useManualTiming ? state.timestamp : performance.now();
    runNextFrame = false;
    state.delta = useDefaultElapsed ? 1e3 / 60 : Math.max(Math.min(timestamp - state.timestamp, maxElapsed), 1);
    state.timestamp = timestamp;
    state.isProcessing = true;
    read.process(state);
    resolveKeyframes.process(state);
    update.process(state);
    preRender.process(state);
    render.process(state);
    postRender.process(state);
    state.isProcessing = false;
    if (runNextFrame && allowKeepAlive) {
      useDefaultElapsed = false;
      scheduleNextBatch(processBatch);
    }
  };
  const wake = () => {
    runNextFrame = true;
    useDefaultElapsed = true;
    if (!state.isProcessing) {
      scheduleNextBatch(processBatch);
    }
  };
  const schedule = stepsOrder.reduce((acc, key) => {
    const step = steps[key];
    acc[key] = (process2, keepAlive = false, immediate = false) => {
      if (!runNextFrame)
        wake();
      return step.schedule(process2, keepAlive, immediate);
    };
    return acc;
  }, {});
  const cancel = (process2) => {
    for (let i = 0; i < stepsOrder.length; i++) {
      steps[stepsOrder[i]].cancel(process2);
    }
  };
  return { schedule, cancel, state, steps };
}

// ../../node_modules/motion/dist/es/framer-motion/dist/es/frameloop/microtask.mjs
var { schedule: microtask, cancel: cancelMicrotask } = createRenderBatcher(queueMicrotask, false);

// ../../node_modules/motion/dist/es/framer-motion/dist/es/context/SwitchLayoutGroupContext.mjs
var import_react9 = __toESM(require_react(), 1);
var SwitchLayoutGroupContext = (0, import_react9.createContext)({});

// ../../node_modules/motion/dist/es/framer-motion/dist/es/motion/utils/use-visual-element.mjs
function useVisualElement(Component, visualState, props, createVisualElement, ProjectionNodeConstructor) {
  var _a, _b;
  const { visualElement: parent } = (0, import_react10.useContext)(MotionContext);
  const lazyContext = (0, import_react10.useContext)(LazyContext);
  const presenceContext = (0, import_react10.useContext)(PresenceContext);
  const reducedMotionConfig = (0, import_react10.useContext)(MotionConfigContext).reducedMotion;
  const visualElementRef = (0, import_react10.useRef)(null);
  createVisualElement = createVisualElement || lazyContext.renderer;
  if (!visualElementRef.current && createVisualElement) {
    visualElementRef.current = createVisualElement(Component, {
      visualState,
      parent,
      props,
      presenceContext,
      blockInitialAnimation: presenceContext ? presenceContext.initial === false : false,
      reducedMotionConfig
    });
  }
  const visualElement = visualElementRef.current;
  const initialLayoutGroupConfig = (0, import_react10.useContext)(SwitchLayoutGroupContext);
  if (visualElement && !visualElement.projection && ProjectionNodeConstructor && (visualElement.type === "html" || visualElement.type === "svg")) {
    createProjectionNode(visualElementRef.current, props, ProjectionNodeConstructor, initialLayoutGroupConfig);
  }
  const isMounted = (0, import_react10.useRef)(false);
  (0, import_react10.useInsertionEffect)(() => {
    if (visualElement && isMounted.current) {
      visualElement.update(props, presenceContext);
    }
  });
  const optimisedAppearId = props[optimizedAppearDataAttribute];
  const wantsHandoff = (0, import_react10.useRef)(Boolean(optimisedAppearId) && !((_a = window.MotionHandoffIsComplete) === null || _a === void 0 ? void 0 : _a.call(window, optimisedAppearId)) && ((_b = window.MotionHasOptimisedAnimation) === null || _b === void 0 ? void 0 : _b.call(window, optimisedAppearId)));
  useIsomorphicLayoutEffect(() => {
    if (!visualElement)
      return;
    isMounted.current = true;
    window.MotionIsMounted = true;
    visualElement.updateFeatures();
    microtask.render(visualElement.render);
    if (wantsHandoff.current && visualElement.animationState) {
      visualElement.animationState.animateChanges();
    }
  });
  (0, import_react10.useEffect)(() => {
    if (!visualElement)
      return;
    if (!wantsHandoff.current && visualElement.animationState) {
      visualElement.animationState.animateChanges();
    }
    if (wantsHandoff.current) {
      queueMicrotask(() => {
        var _a2;
        (_a2 = window.MotionHandoffMarkAsComplete) === null || _a2 === void 0 ? void 0 : _a2.call(window, optimisedAppearId);
      });
      wantsHandoff.current = false;
    }
  });
  return visualElement;
}
function createProjectionNode(visualElement, props, ProjectionNodeConstructor, initialPromotionConfig) {
  const { layoutId, layout, drag, dragConstraints, layoutScroll, layoutRoot } = props;
  visualElement.projection = new ProjectionNodeConstructor(visualElement.latestValues, props["data-framer-portal-id"] ? void 0 : getClosestProjectingNode(visualElement.parent));
  visualElement.projection.setOptions({
    layoutId,
    layout,
    alwaysMeasureLayout: Boolean(drag) || dragConstraints && isRefObject(dragConstraints),
    visualElement,
    /**
     * TODO: Update options in an effect. This could be tricky as it'll be too late
     * to update by the time layout animations run.
     * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,
     * ensuring it gets called if there's no potential layout animations.
     *
     */
    animationType: typeof layout === "string" ? layout : "both",
    initialPromotionConfig,
    layoutScroll,
    layoutRoot
  });
}
function getClosestProjectingNode(visualElement) {
  if (!visualElement)
    return void 0;
  return visualElement.options.allowProjection !== false ? visualElement.projection : getClosestProjectingNode(visualElement.parent);
}

// ../../node_modules/motion/dist/es/framer-motion/dist/es/motion/index.mjs
function createRendererMotionComponent({ preloadedFeatures, createVisualElement, useRender, useVisualState, Component }) {
  var _a, _b;
  preloadedFeatures && loadFeatures(preloadedFeatures);
  function MotionComponent(props, externalRef) {
    let MeasureLayout;
    const configAndProps = {
      ...(0, import_react11.useContext)(MotionConfigContext),
      ...props,
      layoutId: useLayoutId(props)
    };
    const { isStatic } = configAndProps;
    const context = useCreateMotionContext(props);
    const visualState = useVisualState(props, isStatic);
    if (!isStatic && isBrowser) {
      useStrictMode(configAndProps, preloadedFeatures);
      const layoutProjection = getProjectionFunctionality(configAndProps);
      MeasureLayout = layoutProjection.MeasureLayout;
      context.visualElement = useVisualElement(Component, visualState, configAndProps, createVisualElement, layoutProjection.ProjectionNode);
    }
    return (0, import_jsx_runtime.jsxs)(MotionContext.Provider, { value: context, children: [MeasureLayout && context.visualElement ? (0, import_jsx_runtime.jsx)(MeasureLayout, { visualElement: context.visualElement, ...configAndProps }) : null, useRender(Component, props, useMotionRef(visualState, context.visualElement, externalRef), visualState, isStatic, context.visualElement)] });
  }
  MotionComponent.displayName = `motion.${typeof Component === "string" ? Component : `create(${(_b = (_a = Component.displayName) !== null && _a !== void 0 ? _a : Component.name) !== null && _b !== void 0 ? _b : ""})`}`;
  const ForwardRefMotionComponent = (0, import_react11.forwardRef)(MotionComponent);
  ForwardRefMotionComponent[motionComponentSymbol] = Component;
  return ForwardRefMotionComponent;
}
function useLayoutId({ layoutId }) {
  const layoutGroupId = (0, import_react11.useContext)(LayoutGroupContext).id;
  return layoutGroupId && layoutId !== void 0 ? layoutGroupId + "-" + layoutId : layoutId;
}
function useStrictMode(configAndProps, preloadedFeatures) {
  const isStrict = (0, import_react11.useContext)(LazyContext).strict;
  if (preloadedFeatures && isStrict) {
    const strictMessage = "You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.";
    configAndProps.ignoreStrict ? warning(false, strictMessage) : invariant(false, strictMessage);
  }
}
function getProjectionFunctionality(props) {
  const { drag, layout } = featureDefinitions;
  if (!drag && !layout)
    return {};
  const combined = { ...drag, ...layout };
  return {
    MeasureLayout: (drag === null || drag === void 0 ? void 0 : drag.isEnabled(props)) || (layout === null || layout === void 0 ? void 0 : layout.isEnabled(props)) ? combined.MeasureLayout : void 0,
    ProjectionNode: combined.ProjectionNode
  };
}

// ../../node_modules/motion/dist/es/framer-motion/dist/es/render/svg/lowercase-elements.mjs
var lowercaseSVGElements = [
  "animate",
  "circle",
  "defs",
  "desc",
  "ellipse",
  "g",
  "image",
  "line",
  "filter",
  "marker",
  "mask",
  "metadata",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "rect",
  "stop",
  "switch",
  "symbol",
  "svg",
  "text",
  "tspan",
  "use",
  "view"
];

// ../../node_modules/motion/dist/es/framer-motion/dist/es/render/dom/utils/is-svg-component.mjs
function isSVGComponent(Component) {
  if (
    /**
     * If it's not a string, it's a custom React component. Currently we only support
     * HTML custom React components.
     */
    typeof Component !== "string" || /**
     * If it contains a dash, the element is a custom HTML webcomponent.
     */
    Component.includes("-")
  ) {
    return false;
  } else if (
    /**
     * If it's in our list of lowercase SVG tags, it's an SVG component
     */
    lowercaseSVGElements.indexOf(Component) > -1 || /**
     * If it contains a capital letter, it's an SVG component
     */
    /[A-Z]/u.test(Component)
  ) {
    return true;
  }
  return false;
}

// ../../node_modules/motion/dist/es/framer-motion/dist/es/render/html/utils/render.mjs
function renderHTML(element, { style, vars }, styleProp, projection) {
  Object.assign(element.style, style, projection && projection.getProjectionStyles(styleProp));
  for (const key in vars) {
    element.style.setProperty(key, vars[key]);
  }
}

// ../../node_modules/motion/dist/es/framer-motion/dist/es/render/svg/utils/camel-case-attrs.mjs
var camelCaseAttributes = /* @__PURE__ */ new Set([
  "baseFrequency",
  "diffuseConstant",
  "kernelMatrix",
  "kernelUnitLength",
  "keySplines",
  "keyTimes",
  "limitingConeAngle",
  "markerHeight",
  "markerWidth",
  "numOctaves",
  "targetX",
  "targetY",
  "surfaceScale",
  "specularConstant",
  "specularExponent",
  "stdDeviation",
  "tableValues",
  "viewBox",
  "gradientTransform",
  "pathLength",
  "startOffset",
  "textLength",
  "lengthAdjust"
]);

// ../../node_modules/motion/dist/es/framer-motion/dist/es/render/svg/utils/render.mjs
function renderSVG(element, renderState, _styleProp, projection) {
  renderHTML(element, renderState, void 0, projection);
  for (const key in renderState.attrs) {
    element.setAttribute(!camelCaseAttributes.has(key) ? camelToDash(key) : key, renderState.attrs[key]);
  }
}

// ../../node_modules/motion/dist/es/framer-motion/dist/es/value/utils/is-motion-value.mjs
var isMotionValue = (value) => Boolean(value && value.getVelocity);

// ../../node_modules/motion/dist/es/framer-motion/dist/es/render/html/utils/keys-transform.mjs
var transformPropOrder = [
  "transformPerspective",
  "x",
  "y",
  "z",
  "translateX",
  "translateY",
  "translateZ",
  "scale",
  "scaleX",
  "scaleY",
  "rotate",
  "rotateX",
  "rotateY",
  "rotateZ",
  "skew",
  "skewX",
  "skewY"
];
var transformProps = new Set(transformPropOrder);

// ../../node_modules/motion/dist/es/framer-motion/dist/es/projection/styles/scale-correction.mjs
var scaleCorrectors = {};

// ../../node_modules/motion/dist/es/framer-motion/dist/es/motion/utils/is-forced-motion-value.mjs
function isForcedMotionValue(key, { layout, layoutId }) {
  return transformProps.has(key) || key.startsWith("origin") || (layout || layoutId !== void 0) && (!!scaleCorrectors[key] || key === "opacity");
}

// ../../node_modules/motion/dist/es/framer-motion/dist/es/render/html/utils/scrape-motion-values.mjs
function scrapeMotionValuesFromProps(props, prevProps, visualElement) {
  var _a;
  const { style } = props;
  const newValues = {};
  for (const key in style) {
    if (isMotionValue(style[key]) || prevProps.style && isMotionValue(prevProps.style[key]) || isForcedMotionValue(key, props) || ((_a = visualElement === null || visualElement === void 0 ? void 0 : visualElement.getValue(key)) === null || _a === void 0 ? void 0 : _a.liveStyle) !== void 0) {
      newValues[key] = style[key];
    }
  }
  return newValues;
}

// ../../node_modules/motion/dist/es/framer-motion/dist/es/render/svg/utils/scrape-motion-values.mjs
function scrapeMotionValuesFromProps2(props, prevProps, visualElement) {
  const newValues = scrapeMotionValuesFromProps(props, prevProps, visualElement);
  for (const key in props) {
    if (isMotionValue(props[key]) || isMotionValue(prevProps[key])) {
      const targetKey = transformPropOrder.indexOf(key) !== -1 ? "attr" + key.charAt(0).toUpperCase() + key.substring(1) : key;
      newValues[targetKey] = props[key];
    }
  }
  return newValues;
}

// ../../node_modules/motion/dist/es/framer-motion/dist/es/motion/utils/use-visual-state.mjs
var import_react13 = __toESM(require_react(), 1);

// ../../node_modules/motion/dist/es/framer-motion/dist/es/render/utils/resolve-variants.mjs
function getValueState(visualElement) {
  const state = [{}, {}];
  visualElement === null || visualElement === void 0 ? void 0 : visualElement.values.forEach((value, key) => {
    state[0][key] = value.get();
    state[1][key] = value.getVelocity();
  });
  return state;
}
function resolveVariantFromProps(props, definition, custom, visualElement) {
  if (typeof definition === "function") {
    const [current, velocity] = getValueState(visualElement);
    definition = definition(custom !== void 0 ? custom : props.custom, current, velocity);
  }
  if (typeof definition === "string") {
    definition = props.variants && props.variants[definition];
  }
  if (typeof definition === "function") {
    const [current, velocity] = getValueState(visualElement);
    definition = definition(custom !== void 0 ? custom : props.custom, current, velocity);
  }
  return definition;
}

// ../../node_modules/motion/dist/es/framer-motion/dist/es/utils/use-constant.mjs
var import_react12 = __toESM(require_react(), 1);
function useConstant(init) {
  const ref = (0, import_react12.useRef)(null);
  if (ref.current === null) {
    ref.current = init();
  }
  return ref.current;
}

// ../../node_modules/motion/dist/es/framer-motion/dist/es/utils/resolve-value.mjs
var isCustomValue = (v) => {
  return Boolean(v && typeof v === "object" && v.mix && v.toValue);
};

// ../../node_modules/motion/dist/es/framer-motion/dist/es/value/utils/resolve-motion-value.mjs
function resolveMotionValue(value) {
  const unwrappedValue = isMotionValue(value) ? value.get() : value;
  return isCustomValue(unwrappedValue) ? unwrappedValue.toValue() : unwrappedValue;
}

// ../../node_modules/motion/dist/es/framer-motion/dist/es/motion/utils/use-visual-state.mjs
function makeState({ scrapeMotionValuesFromProps: scrapeMotionValuesFromProps3, createRenderState, onMount }, props, context, presenceContext) {
  const state = {
    latestValues: makeLatestValues(props, context, presenceContext, scrapeMotionValuesFromProps3),
    renderState: createRenderState()
  };
  if (onMount) {
    state.mount = (instance) => onMount(props, instance, state);
  }
  return state;
}
var makeUseVisualState = (config) => (props, isStatic) => {
  const context = (0, import_react13.useContext)(MotionContext);
  const presenceContext = (0, import_react13.useContext)(PresenceContext);
  const make = () => makeState(config, props, context, presenceContext);
  return isStatic ? make() : useConstant(make);
};
function makeLatestValues(props, context, presenceContext, scrapeMotionValues) {
  const values = {};
  const motionValues = scrapeMotionValues(props, {});
  for (const key in motionValues) {
    values[key] = resolveMotionValue(motionValues[key]);
  }
  let { initial, animate } = props;
  const isControllingVariants$1 = isControllingVariants(props);
  const isVariantNode$1 = isVariantNode(props);
  if (context && isVariantNode$1 && !isControllingVariants$1 && props.inherit !== false) {
    if (initial === void 0)
      initial = context.initial;
    if (animate === void 0)
      animate = context.animate;
  }
  let isInitialAnimationBlocked = presenceContext ? presenceContext.initial === false : false;
  isInitialAnimationBlocked = isInitialAnimationBlocked || initial === false;
  const variantToSet = isInitialAnimationBlocked ? animate : initial;
  if (variantToSet && typeof variantToSet !== "boolean" && !isAnimationControls(variantToSet)) {
    const list = Array.isArray(variantToSet) ? variantToSet : [variantToSet];
    for (let i = 0; i < list.length; i++) {
      const resolved = resolveVariantFromProps(props, list[i]);
      if (resolved) {
        const { transitionEnd, transition, ...target } = resolved;
        for (const key in target) {
          let valueTarget = target[key];
          if (Array.isArray(valueTarget)) {
            const index = isInitialAnimationBlocked ? valueTarget.length - 1 : 0;
            valueTarget = valueTarget[index];
          }
          if (valueTarget !== null) {
            values[key] = valueTarget;
          }
        }
        for (const key in transitionEnd) {
          values[key] = transitionEnd[key];
        }
      }
    }
  }
  return values;
}

// ../../node_modules/motion/dist/es/framer-motion/dist/es/render/html/utils/create-render-state.mjs
var createHtmlRenderState = () => ({
  style: {},
  transform: {},
  transformOrigin: {},
  vars: {}
});

// ../../node_modules/motion/dist/es/framer-motion/dist/es/render/svg/utils/create-render-state.mjs
var createSvgRenderState = () => ({
  ...createHtmlRenderState(),
  attrs: {}
});

// ../../node_modules/motion/dist/es/framer-motion/dist/es/render/dom/utils/is-css-variable.mjs
var checkStringStartsWith = (token) => (key) => typeof key === "string" && key.startsWith(token);
var isCSSVariableName = checkStringStartsWith("--");
var startsAsVariableToken = checkStringStartsWith("var(--");

// ../../node_modules/motion/dist/es/framer-motion/dist/es/render/dom/value-types/get-as-type.mjs
var getValueAsType = (value, type) => {
  return type && typeof value === "number" ? type.transform(value) : value;
};

// ../../node_modules/motion/dist/es/framer-motion/dist/es/utils/clamp.mjs
var clamp = (min, max, v) => {
  if (v > max)
    return max;
  if (v < min)
    return min;
  return v;
};

// ../../node_modules/motion/dist/es/framer-motion/dist/es/value/types/numbers/index.mjs
var number = {
  test: (v) => typeof v === "number",
  parse: parseFloat,
  transform: (v) => v
};
var alpha = {
  ...number,
  transform: (v) => clamp(0, 1, v)
};
var scale = {
  ...number,
  default: 1
};

// ../../node_modules/motion/dist/es/framer-motion/dist/es/value/types/numbers/units.mjs
var createUnitType = (unit) => ({
  test: (v) => typeof v === "string" && v.endsWith(unit) && v.split(" ").length === 1,
  parse: parseFloat,
  transform: (v) => `${v}${unit}`
});
var degrees = createUnitType("deg");
var percent = createUnitType("%");
var px = createUnitType("px");
var vh = createUnitType("vh");
var vw = createUnitType("vw");
var progressPercentage = {
  ...percent,
  parse: (v) => percent.parse(v) / 100,
  transform: (v) => percent.transform(v * 100)
};

// ../../node_modules/motion/dist/es/framer-motion/dist/es/render/dom/value-types/number-browser.mjs
var browserNumberValueTypes = {
  // Border props
  borderWidth: px,
  borderTopWidth: px,
  borderRightWidth: px,
  borderBottomWidth: px,
  borderLeftWidth: px,
  borderRadius: px,
  radius: px,
  borderTopLeftRadius: px,
  borderTopRightRadius: px,
  borderBottomRightRadius: px,
  borderBottomLeftRadius: px,
  // Positioning props
  width: px,
  maxWidth: px,
  height: px,
  maxHeight: px,
  top: px,
  right: px,
  bottom: px,
  left: px,
  // Spacing props
  padding: px,
  paddingTop: px,
  paddingRight: px,
  paddingBottom: px,
  paddingLeft: px,
  margin: px,
  marginTop: px,
  marginRight: px,
  marginBottom: px,
  marginLeft: px,
  // Misc
  backgroundPositionX: px,
  backgroundPositionY: px
};

// ../../node_modules/motion/dist/es/framer-motion/dist/es/render/dom/value-types/transform.mjs
var transformValueTypes = {
  rotate: degrees,
  rotateX: degrees,
  rotateY: degrees,
  rotateZ: degrees,
  scale,
  scaleX: scale,
  scaleY: scale,
  scaleZ: scale,
  skew: degrees,
  skewX: degrees,
  skewY: degrees,
  distance: px,
  translateX: px,
  translateY: px,
  translateZ: px,
  x: px,
  y: px,
  z: px,
  perspective: px,
  transformPerspective: px,
  opacity: alpha,
  originX: progressPercentage,
  originY: progressPercentage,
  originZ: px
};

// ../../node_modules/motion/dist/es/framer-motion/dist/es/render/dom/value-types/type-int.mjs
var int = {
  ...number,
  transform: Math.round
};

// ../../node_modules/motion/dist/es/framer-motion/dist/es/render/dom/value-types/number.mjs
var numberValueTypes = {
  ...browserNumberValueTypes,
  ...transformValueTypes,
  zIndex: int,
  size: px,
  // SVG
  fillOpacity: alpha,
  strokeOpacity: alpha,
  numOctaves: int
};

// ../../node_modules/motion/dist/es/framer-motion/dist/es/render/html/utils/build-transform.mjs
var translateAlias = {
  x: "translateX",
  y: "translateY",
  z: "translateZ",
  transformPerspective: "perspective"
};
var numTransforms = transformPropOrder.length;
function buildTransform(latestValues, transform, transformTemplate) {
  let transformString = "";
  let transformIsDefault = true;
  for (let i = 0; i < numTransforms; i++) {
    const key = transformPropOrder[i];
    const value = latestValues[key];
    if (value === void 0)
      continue;
    let valueIsDefault = true;
    if (typeof value === "number") {
      valueIsDefault = value === (key.startsWith("scale") ? 1 : 0);
    } else {
      valueIsDefault = parseFloat(value) === 0;
    }
    if (!valueIsDefault || transformTemplate) {
      const valueAsType = getValueAsType(value, numberValueTypes[key]);
      if (!valueIsDefault) {
        transformIsDefault = false;
        const transformName = translateAlias[key] || key;
        transformString += `${transformName}(${valueAsType}) `;
      }
      if (transformTemplate) {
        transform[key] = valueAsType;
      }
    }
  }
  transformString = transformString.trim();
  if (transformTemplate) {
    transformString = transformTemplate(transform, transformIsDefault ? "" : transformString);
  } else if (transformIsDefault) {
    transformString = "none";
  }
  return transformString;
}

// ../../node_modules/motion/dist/es/framer-motion/dist/es/render/html/utils/build-styles.mjs
function buildHTMLStyles(state, latestValues, transformTemplate) {
  const { style, vars, transformOrigin } = state;
  let hasTransform = false;
  let hasTransformOrigin = false;
  for (const key in latestValues) {
    const value = latestValues[key];
    if (transformProps.has(key)) {
      hasTransform = true;
      continue;
    } else if (isCSSVariableName(key)) {
      vars[key] = value;
      continue;
    } else {
      const valueAsType = getValueAsType(value, numberValueTypes[key]);
      if (key.startsWith("origin")) {
        hasTransformOrigin = true;
        transformOrigin[key] = valueAsType;
      } else {
        style[key] = valueAsType;
      }
    }
  }
  if (!latestValues.transform) {
    if (hasTransform || transformTemplate) {
      style.transform = buildTransform(latestValues, state.transform, transformTemplate);
    } else if (style.transform) {
      style.transform = "none";
    }
  }
  if (hasTransformOrigin) {
    const { originX = "50%", originY = "50%", originZ = 0 } = transformOrigin;
    style.transformOrigin = `${originX} ${originY} ${originZ}`;
  }
}

// ../../node_modules/motion/dist/es/framer-motion/dist/es/render/svg/utils/transform-origin.mjs
function calcOrigin(origin, offset, size) {
  return typeof origin === "string" ? origin : px.transform(offset + size * origin);
}
function calcSVGTransformOrigin(dimensions, originX, originY) {
  const pxOriginX = calcOrigin(originX, dimensions.x, dimensions.width);
  const pxOriginY = calcOrigin(originY, dimensions.y, dimensions.height);
  return `${pxOriginX} ${pxOriginY}`;
}

// ../../node_modules/motion/dist/es/framer-motion/dist/es/render/svg/utils/path.mjs
var dashKeys = {
  offset: "stroke-dashoffset",
  array: "stroke-dasharray"
};
var camelKeys = {
  offset: "strokeDashoffset",
  array: "strokeDasharray"
};
function buildSVGPath(attrs, length, spacing = 1, offset = 0, useDashCase = true) {
  attrs.pathLength = 1;
  const keys = useDashCase ? dashKeys : camelKeys;
  attrs[keys.offset] = px.transform(-offset);
  const pathLength = px.transform(length);
  const pathSpacing = px.transform(spacing);
  attrs[keys.array] = `${pathLength} ${pathSpacing}`;
}

// ../../node_modules/motion/dist/es/framer-motion/dist/es/render/svg/utils/build-attrs.mjs
function buildSVGAttrs(state, {
  attrX,
  attrY,
  attrScale,
  originX,
  originY,
  pathLength,
  pathSpacing = 1,
  pathOffset = 0,
  // This is object creation, which we try to avoid per-frame.
  ...latest
}, isSVGTag2, transformTemplate) {
  buildHTMLStyles(state, latest, transformTemplate);
  if (isSVGTag2) {
    if (state.style.viewBox) {
      state.attrs.viewBox = state.style.viewBox;
    }
    return;
  }
  state.attrs = state.style;
  state.style = {};
  const { attrs, style, dimensions } = state;
  if (attrs.transform) {
    if (dimensions)
      style.transform = attrs.transform;
    delete attrs.transform;
  }
  if (dimensions && (originX !== void 0 || originY !== void 0 || style.transform)) {
    style.transformOrigin = calcSVGTransformOrigin(dimensions, originX !== void 0 ? originX : 0.5, originY !== void 0 ? originY : 0.5);
  }
  if (attrX !== void 0)
    attrs.x = attrX;
  if (attrY !== void 0)
    attrs.y = attrY;
  if (attrScale !== void 0)
    attrs.scale = attrScale;
  if (pathLength !== void 0) {
    buildSVGPath(attrs, pathLength, pathSpacing, pathOffset, false);
  }
}

// ../../node_modules/motion/dist/es/framer-motion/dist/es/render/svg/utils/is-svg-tag.mjs
var isSVGTag = (tag) => typeof tag === "string" && tag.toLowerCase() === "svg";

// ../../node_modules/motion/dist/es/framer-motion/dist/es/frameloop/frame.mjs
var { schedule: frame, cancel: cancelFrame, state: frameData, steps: frameSteps } = createRenderBatcher(typeof requestAnimationFrame !== "undefined" ? requestAnimationFrame : noop, true);

// ../../node_modules/motion/dist/es/framer-motion/dist/es/render/svg/config-motion.mjs
var svgMotionConfig = {
  useVisualState: makeUseVisualState({
    scrapeMotionValuesFromProps: scrapeMotionValuesFromProps2,
    createRenderState: createSvgRenderState,
    onMount: (props, instance, { renderState, latestValues }) => {
      frame.read(() => {
        try {
          renderState.dimensions = typeof instance.getBBox === "function" ? instance.getBBox() : instance.getBoundingClientRect();
        } catch (e) {
          renderState.dimensions = {
            x: 0,
            y: 0,
            width: 0,
            height: 0
          };
        }
      });
      frame.render(() => {
        buildSVGAttrs(renderState, latestValues, isSVGTag(instance.tagName), props.transformTemplate);
        renderSVG(instance, renderState);
      });
    }
  })
};

// ../../node_modules/motion/dist/es/framer-motion/dist/es/render/html/config-motion.mjs
var htmlMotionConfig = {
  useVisualState: makeUseVisualState({
    scrapeMotionValuesFromProps,
    createRenderState: createHtmlRenderState
  })
};

// ../../node_modules/motion/dist/es/framer-motion/dist/es/render/dom/use-render.mjs
var import_react16 = __toESM(require_react(), 1);

// ../../node_modules/motion/dist/es/framer-motion/dist/es/render/html/use-props.mjs
var import_react14 = __toESM(require_react(), 1);
function copyRawValuesOnly(target, source, props) {
  for (const key in source) {
    if (!isMotionValue(source[key]) && !isForcedMotionValue(key, props)) {
      target[key] = source[key];
    }
  }
}
function useInitialMotionValues({ transformTemplate }, visualState) {
  return (0, import_react14.useMemo)(() => {
    const state = createHtmlRenderState();
    buildHTMLStyles(state, visualState, transformTemplate);
    return Object.assign({}, state.vars, state.style);
  }, [visualState]);
}
function useStyle(props, visualState) {
  const styleProp = props.style || {};
  const style = {};
  copyRawValuesOnly(style, styleProp, props);
  Object.assign(style, useInitialMotionValues(props, visualState));
  return style;
}
function useHTMLProps(props, visualState) {
  const htmlProps = {};
  const style = useStyle(props, visualState);
  if (props.drag && props.dragListener !== false) {
    htmlProps.draggable = false;
    style.userSelect = style.WebkitUserSelect = style.WebkitTouchCallout = "none";
    style.touchAction = props.drag === true ? "none" : `pan-${props.drag === "x" ? "y" : "x"}`;
  }
  if (props.tabIndex === void 0 && (props.onTap || props.onTapStart || props.whileTap)) {
    htmlProps.tabIndex = 0;
  }
  htmlProps.style = style;
  return htmlProps;
}

// ../../node_modules/motion/dist/es/framer-motion/dist/es/motion/utils/valid-prop.mjs
var validMotionProps = /* @__PURE__ */ new Set([
  "animate",
  "exit",
  "variants",
  "initial",
  "style",
  "values",
  "variants",
  "transition",
  "transformTemplate",
  "custom",
  "inherit",
  "onBeforeLayoutMeasure",
  "onAnimationStart",
  "onAnimationComplete",
  "onUpdate",
  "onDragStart",
  "onDrag",
  "onDragEnd",
  "onMeasureDragConstraints",
  "onDirectionLock",
  "onDragTransitionEnd",
  "_dragX",
  "_dragY",
  "onHoverStart",
  "onHoverEnd",
  "onViewportEnter",
  "onViewportLeave",
  "globalTapTarget",
  "ignoreStrict",
  "viewport"
]);
function isValidMotionProp(key) {
  return key.startsWith("while") || key.startsWith("drag") && key !== "draggable" || key.startsWith("layout") || key.startsWith("onTap") || key.startsWith("onPan") || key.startsWith("onLayout") || validMotionProps.has(key);
}

// ../../node_modules/motion/dist/es/framer-motion/dist/es/render/dom/utils/filter-props.mjs
var shouldForward = (key) => !isValidMotionProp(key);
function loadExternalIsValidProp(isValidProp) {
  if (!isValidProp)
    return;
  shouldForward = (key) => key.startsWith("on") ? !isValidMotionProp(key) : isValidProp(key);
}
try {
  loadExternalIsValidProp(require_is_prop_valid_motion_true().default);
} catch (_a) {
}
function filterProps(props, isDom, forwardMotionProps) {
  const filteredProps = {};
  for (const key in props) {
    if (key === "values" && typeof props.values === "object")
      continue;
    if (shouldForward(key) || forwardMotionProps === true && isValidMotionProp(key) || !isDom && !isValidMotionProp(key) || // If trying to use native HTML drag events, forward drag listeners
    props["draggable"] && key.startsWith("onDrag")) {
      filteredProps[key] = props[key];
    }
  }
  return filteredProps;
}

// ../../node_modules/motion/dist/es/framer-motion/dist/es/render/svg/use-props.mjs
var import_react15 = __toESM(require_react(), 1);
function useSVGProps(props, visualState, _isStatic, Component) {
  const visualProps = (0, import_react15.useMemo)(() => {
    const state = createSvgRenderState();
    buildSVGAttrs(state, visualState, isSVGTag(Component), props.transformTemplate);
    return {
      ...state.attrs,
      style: { ...state.style }
    };
  }, [visualState]);
  if (props.style) {
    const rawStyles = {};
    copyRawValuesOnly(rawStyles, props.style, props);
    visualProps.style = { ...rawStyles, ...visualProps.style };
  }
  return visualProps;
}

// ../../node_modules/motion/dist/es/framer-motion/dist/es/render/dom/use-render.mjs
function createUseRender(forwardMotionProps = false) {
  const useRender = (Component, props, ref, { latestValues }, isStatic) => {
    const useVisualProps = isSVGComponent(Component) ? useSVGProps : useHTMLProps;
    const visualProps = useVisualProps(props, latestValues, isStatic, Component);
    const filteredProps = filterProps(props, typeof Component === "string", forwardMotionProps);
    const elementProps = Component !== import_react16.Fragment ? { ...filteredProps, ...visualProps, ref } : {};
    const { children } = props;
    const renderedChildren = (0, import_react16.useMemo)(() => isMotionValue(children) ? children.get() : children, [children]);
    return (0, import_react16.createElement)(Component, {
      ...elementProps,
      children: renderedChildren
    });
  };
  return useRender;
}

// ../../node_modules/motion/dist/es/framer-motion/dist/es/render/components/create-factory.mjs
function createMotionComponentFactory(preloadedFeatures, createVisualElement) {
  return function createMotionComponent(Component, { forwardMotionProps } = { forwardMotionProps: false }) {
    const baseConfig = isSVGComponent(Component) ? svgMotionConfig : htmlMotionConfig;
    const config = {
      ...baseConfig,
      preloadedFeatures,
      useRender: createUseRender(forwardMotionProps),
      createVisualElement,
      Component
    };
    return createRendererMotionComponent(config);
  };
}

// ../../node_modules/motion/dist/es/framer-motion/dist/es/render/components/m/create.mjs
var createMinimalMotionComponent = createMotionComponentFactory();

// ../../node_modules/motion/dist/es/framer-motion/dist/es/render/components/m/elements.mjs
var MotionA = createMinimalMotionComponent("a");
var MotionAbbr = createMinimalMotionComponent("abbr");
var MotionAddress = createMinimalMotionComponent("address");
var MotionArea = createMinimalMotionComponent("area");
var MotionArticle = createMinimalMotionComponent("article");
var MotionAside = createMinimalMotionComponent("aside");
var MotionAudio = createMinimalMotionComponent("audio");
var MotionB = createMinimalMotionComponent("b");
var MotionBase = createMinimalMotionComponent("base");
var MotionBdi = createMinimalMotionComponent("bdi");
var MotionBdo = createMinimalMotionComponent("bdo");
var MotionBig = createMinimalMotionComponent("big");
var MotionBlockquote = createMinimalMotionComponent("blockquote");
var MotionBody = createMinimalMotionComponent("body");
var MotionButton = createMinimalMotionComponent("button");
var MotionCanvas = createMinimalMotionComponent("canvas");
var MotionCaption = createMinimalMotionComponent("caption");
var MotionCite = createMinimalMotionComponent("cite");
var MotionCode = createMinimalMotionComponent("code");
var MotionCol = createMinimalMotionComponent("col");
var MotionColgroup = createMinimalMotionComponent("colgroup");
var MotionData = createMinimalMotionComponent("data");
var MotionDatalist = createMinimalMotionComponent("datalist");
var MotionDd = createMinimalMotionComponent("dd");
var MotionDel = createMinimalMotionComponent("del");
var MotionDetails = createMinimalMotionComponent("details");
var MotionDfn = createMinimalMotionComponent("dfn");
var MotionDialog = createMinimalMotionComponent("dialog");
var MotionDiv = createMinimalMotionComponent("div");
var MotionDl = createMinimalMotionComponent("dl");
var MotionDt = createMinimalMotionComponent("dt");
var MotionEm = createMinimalMotionComponent("em");
var MotionEmbed = createMinimalMotionComponent("embed");
var MotionFieldset = createMinimalMotionComponent("fieldset");
var MotionFigcaption = createMinimalMotionComponent("figcaption");
var MotionFigure = createMinimalMotionComponent("figure");
var MotionFooter = createMinimalMotionComponent("footer");
var MotionForm = createMinimalMotionComponent("form");
var MotionH1 = createMinimalMotionComponent("h1");
var MotionH2 = createMinimalMotionComponent("h2");
var MotionH3 = createMinimalMotionComponent("h3");
var MotionH4 = createMinimalMotionComponent("h4");
var MotionH5 = createMinimalMotionComponent("h5");
var MotionH6 = createMinimalMotionComponent("h6");
var MotionHead = createMinimalMotionComponent("head");
var MotionHeader = createMinimalMotionComponent("header");
var MotionHgroup = createMinimalMotionComponent("hgroup");
var MotionHr = createMinimalMotionComponent("hr");
var MotionHtml = createMinimalMotionComponent("html");
var MotionI = createMinimalMotionComponent("i");
var MotionIframe = createMinimalMotionComponent("iframe");
var MotionImg = createMinimalMotionComponent("img");
var MotionInput = createMinimalMotionComponent("input");
var MotionIns = createMinimalMotionComponent("ins");
var MotionKbd = createMinimalMotionComponent("kbd");
var MotionKeygen = createMinimalMotionComponent("keygen");
var MotionLabel = createMinimalMotionComponent("label");
var MotionLegend = createMinimalMotionComponent("legend");
var MotionLi = createMinimalMotionComponent("li");
var MotionLink = createMinimalMotionComponent("link");
var MotionMain = createMinimalMotionComponent("main");
var MotionMap = createMinimalMotionComponent("map");
var MotionMark = createMinimalMotionComponent("mark");
var MotionMenu = createMinimalMotionComponent("menu");
var MotionMenuitem = createMinimalMotionComponent("menuitem");
var MotionMeter = createMinimalMotionComponent("meter");
var MotionNav = createMinimalMotionComponent("nav");
var MotionObject = createMinimalMotionComponent("object");
var MotionOl = createMinimalMotionComponent("ol");
var MotionOptgroup = createMinimalMotionComponent("optgroup");
var MotionOption = createMinimalMotionComponent("option");
var MotionOutput = createMinimalMotionComponent("output");
var MotionP = createMinimalMotionComponent("p");
var MotionParam = createMinimalMotionComponent("param");
var MotionPicture = createMinimalMotionComponent("picture");
var MotionPre = createMinimalMotionComponent("pre");
var MotionProgress = createMinimalMotionComponent("progress");
var MotionQ = createMinimalMotionComponent("q");
var MotionRp = createMinimalMotionComponent("rp");
var MotionRt = createMinimalMotionComponent("rt");
var MotionRuby = createMinimalMotionComponent("ruby");
var MotionS = createMinimalMotionComponent("s");
var MotionSamp = createMinimalMotionComponent("samp");
var MotionScript = createMinimalMotionComponent("script");
var MotionSection = createMinimalMotionComponent("section");
var MotionSelect = createMinimalMotionComponent("select");
var MotionSmall = createMinimalMotionComponent("small");
var MotionSource = createMinimalMotionComponent("source");
var MotionSpan = createMinimalMotionComponent("span");
var MotionStrong = createMinimalMotionComponent("strong");
var MotionStyle = createMinimalMotionComponent("style");
var MotionSub = createMinimalMotionComponent("sub");
var MotionSummary = createMinimalMotionComponent("summary");
var MotionSup = createMinimalMotionComponent("sup");
var MotionTable = createMinimalMotionComponent("table");
var MotionTbody = createMinimalMotionComponent("tbody");
var MotionTd = createMinimalMotionComponent("td");
var MotionTextarea = createMinimalMotionComponent("textarea");
var MotionTfoot = createMinimalMotionComponent("tfoot");
var MotionTh = createMinimalMotionComponent("th");
var MotionThead = createMinimalMotionComponent("thead");
var MotionTime = createMinimalMotionComponent("time");
var MotionTitle = createMinimalMotionComponent("title");
var MotionTr = createMinimalMotionComponent("tr");
var MotionTrack = createMinimalMotionComponent("track");
var MotionU = createMinimalMotionComponent("u");
var MotionUl = createMinimalMotionComponent("ul");
var MotionVideo = createMinimalMotionComponent("video");
var MotionWbr = createMinimalMotionComponent("wbr");
var MotionWebview = createMinimalMotionComponent("webview");
var MotionAnimate = createMinimalMotionComponent("animate");
var MotionCircle = createMinimalMotionComponent("circle");
var MotionDefs = createMinimalMotionComponent("defs");
var MotionDesc = createMinimalMotionComponent("desc");
var MotionEllipse = createMinimalMotionComponent("ellipse");
var MotionG = createMinimalMotionComponent("g");
var MotionImage = createMinimalMotionComponent("image");
var MotionLine = createMinimalMotionComponent("line");
var MotionFilter = createMinimalMotionComponent("filter");
var MotionMarker = createMinimalMotionComponent("marker");
var MotionMask = createMinimalMotionComponent("mask");
var MotionMetadata = createMinimalMotionComponent("metadata");
var MotionPath = createMinimalMotionComponent("path");
var MotionPattern = createMinimalMotionComponent("pattern");
var MotionPolygon = createMinimalMotionComponent("polygon");
var MotionPolyline = createMinimalMotionComponent("polyline");
var MotionRect = createMinimalMotionComponent("rect");
var MotionStop = createMinimalMotionComponent("stop");
var MotionSvg = createMinimalMotionComponent("svg");
var MotionSymbol = createMinimalMotionComponent("symbol");
var MotionText = createMinimalMotionComponent("text");
var MotionTspan = createMinimalMotionComponent("tspan");
var MotionUse = createMinimalMotionComponent("use");
var MotionView = createMinimalMotionComponent("view");
var MotionClipPath = createMinimalMotionComponent("clipPath");
var MotionFeBlend = createMinimalMotionComponent("feBlend");
var MotionFeColorMatrix = createMinimalMotionComponent("feColorMatrix");
var MotionFeComponentTransfer = createMinimalMotionComponent("feComponentTransfer");
var MotionFeComposite = createMinimalMotionComponent("feComposite");
var MotionFeConvolveMatrix = createMinimalMotionComponent("feConvolveMatrix");
var MotionFeDiffuseLighting = createMinimalMotionComponent("feDiffuseLighting");
var MotionFeDisplacementMap = createMinimalMotionComponent("feDisplacementMap");
var MotionFeDistantLight = createMinimalMotionComponent("feDistantLight");
var MotionFeDropShadow = createMinimalMotionComponent("feDropShadow");
var MotionFeFlood = createMinimalMotionComponent("feFlood");
var MotionFeFuncA = createMinimalMotionComponent("feFuncA");
var MotionFeFuncB = createMinimalMotionComponent("feFuncB");
var MotionFeFuncG = createMinimalMotionComponent("feFuncG");
var MotionFeFuncR = createMinimalMotionComponent("feFuncR");
var MotionFeGaussianBlur = createMinimalMotionComponent("feGaussianBlur");
var MotionFeImage = createMinimalMotionComponent("feImage");
var MotionFeMerge = createMinimalMotionComponent("feMerge");
var MotionFeMergeNode = createMinimalMotionComponent("feMergeNode");
var MotionFeMorphology = createMinimalMotionComponent("feMorphology");
var MotionFeOffset = createMinimalMotionComponent("feOffset");
var MotionFePointLight = createMinimalMotionComponent("fePointLight");
var MotionFeSpecularLighting = createMinimalMotionComponent("feSpecularLighting");
var MotionFeSpotLight = createMinimalMotionComponent("feSpotLight");
var MotionFeTile = createMinimalMotionComponent("feTile");
var MotionFeTurbulence = createMinimalMotionComponent("feTurbulence");
var MotionForeignObject = createMinimalMotionComponent("foreignObject");
var MotionLinearGradient = createMinimalMotionComponent("linearGradient");
var MotionRadialGradient = createMinimalMotionComponent("radialGradient");
var MotionTextPath = createMinimalMotionComponent("textPath");
export {
  MotionA as a,
  MotionAbbr as abbr,
  MotionAddress as address,
  MotionAnimate as animate,
  MotionArea as area,
  MotionArticle as article,
  MotionAside as aside,
  MotionAudio as audio,
  MotionB as b,
  MotionBase as base,
  MotionBdi as bdi,
  MotionBdo as bdo,
  MotionBig as big,
  MotionBlockquote as blockquote,
  MotionBody as body,
  MotionButton as button,
  MotionCanvas as canvas,
  MotionCaption as caption,
  MotionCircle as circle,
  MotionCite as cite,
  MotionClipPath as clipPath,
  MotionCode as code,
  MotionCol as col,
  MotionColgroup as colgroup,
  createMinimalMotionComponent as create,
  MotionData as data,
  MotionDatalist as datalist,
  MotionDd as dd,
  MotionDefs as defs,
  MotionDel as del,
  MotionDesc as desc,
  MotionDetails as details,
  MotionDfn as dfn,
  MotionDialog as dialog,
  MotionDiv as div,
  MotionDl as dl,
  MotionDt as dt,
  MotionEllipse as ellipse,
  MotionEm as em,
  MotionEmbed as embed,
  MotionFeBlend as feBlend,
  MotionFeColorMatrix as feColorMatrix,
  MotionFeComponentTransfer as feComponentTransfer,
  MotionFeComposite as feComposite,
  MotionFeConvolveMatrix as feConvolveMatrix,
  MotionFeDiffuseLighting as feDiffuseLighting,
  MotionFeDisplacementMap as feDisplacementMap,
  MotionFeDistantLight as feDistantLight,
  MotionFeDropShadow as feDropShadow,
  MotionFeFlood as feFlood,
  MotionFeFuncA as feFuncA,
  MotionFeFuncB as feFuncB,
  MotionFeFuncG as feFuncG,
  MotionFeFuncR as feFuncR,
  MotionFeGaussianBlur as feGaussianBlur,
  MotionFeImage as feImage,
  MotionFeMerge as feMerge,
  MotionFeMergeNode as feMergeNode,
  MotionFeMorphology as feMorphology,
  MotionFeOffset as feOffset,
  MotionFePointLight as fePointLight,
  MotionFeSpecularLighting as feSpecularLighting,
  MotionFeSpotLight as feSpotLight,
  MotionFeTile as feTile,
  MotionFeTurbulence as feTurbulence,
  MotionFieldset as fieldset,
  MotionFigcaption as figcaption,
  MotionFigure as figure,
  MotionFilter as filter,
  MotionFooter as footer,
  MotionForeignObject as foreignObject,
  MotionForm as form,
  MotionG as g,
  MotionH1 as h1,
  MotionH2 as h2,
  MotionH3 as h3,
  MotionH4 as h4,
  MotionH5 as h5,
  MotionH6 as h6,
  MotionHead as head,
  MotionHeader as header,
  MotionHgroup as hgroup,
  MotionHr as hr,
  MotionHtml as html,
  MotionI as i,
  MotionIframe as iframe,
  MotionImage as image,
  MotionImg as img,
  MotionInput as input,
  MotionIns as ins,
  MotionKbd as kbd,
  MotionKeygen as keygen,
  MotionLabel as label,
  MotionLegend as legend,
  MotionLi as li,
  MotionLine as line,
  MotionLinearGradient as linearGradient,
  MotionLink as link,
  MotionMain as main,
  MotionMap as map,
  MotionMark as mark,
  MotionMarker as marker,
  MotionMask as mask,
  MotionMenu as menu,
  MotionMenuitem as menuitem,
  MotionMetadata as metadata,
  MotionMeter as meter,
  MotionNav as nav,
  MotionObject as object,
  MotionOl as ol,
  MotionOptgroup as optgroup,
  MotionOption as option,
  MotionOutput as output,
  MotionP as p,
  MotionParam as param,
  MotionPath as path,
  MotionPattern as pattern,
  MotionPicture as picture,
  MotionPolygon as polygon,
  MotionPolyline as polyline,
  MotionPre as pre,
  MotionProgress as progress,
  MotionQ as q,
  MotionRadialGradient as radialGradient,
  MotionRect as rect,
  MotionRp as rp,
  MotionRt as rt,
  MotionRuby as ruby,
  MotionS as s,
  MotionSamp as samp,
  MotionScript as script,
  MotionSection as section,
  MotionSelect as select,
  MotionSmall as small,
  MotionSource as source,
  MotionSpan as span,
  MotionStop as stop,
  MotionStrong as strong,
  MotionStyle as style,
  MotionSub as sub,
  MotionSummary as summary,
  MotionSup as sup,
  MotionSvg as svg,
  MotionSymbol as symbol,
  MotionTable as table,
  MotionTbody as tbody,
  MotionTd as td,
  MotionText as text,
  MotionTextPath as textPath,
  MotionTextarea as textarea,
  MotionTfoot as tfoot,
  MotionTh as th,
  MotionThead as thead,
  MotionTime as time,
  MotionTitle as title,
  MotionTr as tr,
  MotionTrack as track,
  MotionTspan as tspan,
  MotionU as u,
  MotionUl as ul,
  MotionUse as use,
  MotionVideo as video,
  MotionView as view,
  MotionWbr as wbr,
  MotionWebview as webview
};
//# sourceMappingURL=motion_react-m.js.map
